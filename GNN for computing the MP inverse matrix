# -*- coding: utf-8 -*-
"""Copy of Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/111S2JDUvL5ohWLU0ljAna-fvSKNVG5JA
"""

import numpy as np
import matplotlib.pyplot as plt

class MoorePenroseDifferentialSolver:
    def __init__(self, A, gamma, dt=0.01, tol=1e-15, max_iter=150000):
        """
        Initialize the differential equation solver for Moore-Penrose Inversion.

        Parameters:
        - A: Input matrix (m x n)
        - gamma: Gain parameter
        - dt: Time step for numerical integration
        - tol: Convergence tolerance
        - max_iter: Maximum number of iterations
        """
        self.A = A
        self.gamma = gamma
        self.dt = dt
        self.tol = tol
        self.max_iter = max_iter
        self.m, self.n = A.shape
        self.X = A.T / np.linalg.norm(A, ord='fro') ** 2
        self.residuals = []  # Store residual norms for plotting

    def compute_epsilon(self):
        """Calculate ε(t)."""
        ATA = self.A.T @ self.A
        return ATA @ self.X - self.A.T

    def compute_dX(self):
        """Calculate ˙X(t) based on the differential equation."""
        ATA = self.A.T @ self.A
        epsilon = self.compute_epsilon()
        return -self.gamma * ATA @ epsilon

    def solve(self):
        """Solve for the Moore-Penrose inverse using differential equation dynamics."""
        for iteration in range(self.max_iter):
            dX = self.compute_dX()
            self.X += self.dt * dX  # Euler's method

            # Compute residual norm for convergence checking
            residual_norm = np.linalg.norm(self.compute_epsilon(), ord='fro')
            self.residuals.append(residual_norm)

            if residual_norm < self.tol:
                print(f"Converged in {iteration + 1} iterations with residual norm {residual_norm:.2e}.")
                break
        else:
            print("Reached maximum iterations without full convergence.")
        return self.X

    def plot_convergence(self):
        """Plot the convergence behavior."""
        plt.figure(figsize=(8, 6))
        plt.plot(self.residuals, label="Residual Norm")
        plt.yscale('log')  # Logarithmic scale for better visualization
        plt.xlabel('Iteration')
        plt.ylabel('Residual Norm (Frobenius)')
        plt.title('Convergence of Residual Norm')
        plt.legend()
        plt.grid(True)
        plt.show()


def create_matrix_t(t):
    """Generate the matrix A(t) with rescaling."""
    cos_val = np.cos(np.pi * t / 2)
    sin_val = np.sin(np.pi * t / 2)
    A_t = np.array([
      [t, t**2],
      [sin_val, -cos_val],
      [1/t, np.sqrt(t)]
    ])
    return A_t / np.linalg.norm(A_t, ord='fro')  # Rescale matrix

if __name__ == "__main__":
    for t in np.linspace(0, 2, 5):  # Example range for t
        print(f"\nTesting for t = {t}")
        A_t = create_matrix_t(t)
        print("Matrix A(t):")
        print(A_t)

        gamma = 0.1  # Gain parameter

        # Use stiff solver implementation
        solver = MoorePenroseDifferentialSolver(A_t, gamma=gamma)
        A_pseudo_inverse = solver.solve()

        print("\nComputed Moore-Penrose Inverse:")
        print(A_pseudo_inverse)

        # Validation
        print("\nValidation (A @ A+ @ A should equal A):")
        print(np.round(A_t @ A_pseudo_inverse @ A_t, decimals=6))

        print("\nValidation (A+ @ A @ A+ should equal A+):")
        print(np.round(A_pseudo_inverse @ A_t @ A_pseudo_inverse, decimals=6))

        # Plot convergence
        solver.plot_convergence()
